// This example reads the ambient light using the Maxim MAX44000PMB1 Pmod


/***************************** Include Files **********************************/
#include "xparameters.h"
#include "xiicps.h"
#include "xil_printf.h"
#include <stdio.h>
#include "sleep.h"
#include "xgpio.h"

#define IIC_ADDRESS            0x21   //!< The actual address is 8'b1001 010x (0x94)


int I2C_write(u8 register_offset, u8 write_value);
int I2C_read(u8 register_offset, u8 *read_value);

XIicPs Iic;		/**< Instance of the IIC Device */

#define CAMERA_DEVICE_ID  XPAR_GPIO_1_DEVICE_ID

//XGpio Gpio;

/*
 * The following constant is used to wait after an LED is turned on to make
 * sure that it is visible to the human eye.  This constant might need to be
 * tuned for faster or slower processor speeds.
 */
#define LED_DELAY		10000000

/*
 * Following constant define the Input and Output pins.
 */
#define LED1		47	/* Pin connected to JX3.40, LED/Output */
#define LED2		50	/* Pin connected to JX3.66, LED/Output */
#define PB			51	/* Pin connected to Switch/Input */
#define MUX_SEL		0   /* Pin connected to eMMC/Pmod mux select */

#define LED_MAX_BLINK		0x10	/* Number of times the LED Blinks */

XGpio Gpio;	/* The driver instance for GPIO Device. */
XGpio Gpio2;

int main()
{
	u8 LuxHighByte=0;

	XIicPs_Config *Config;
	int Status;
	u32 InputData;

	Status = XGpio_Initialize(&Gpio, CAMERA_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		xil_printf("Gpio Initialization Failed\r\n");
		return XST_FAILURE;
	}
	XGpio_SetDataDirection(&Gpio, 1, 0x7ff);

	Status = XGpio_Initialize(&Gpio2, 0);
	if (Status != XST_SUCCESS) {
		xil_printf("Gpio Initialization Failed\r\n");
		return XST_FAILURE;
	}
	XGpio_SetDataDirection(&Gpio2, 2, 0x0);
	XGpio_SetDataDirection(&Gpio2, 1, 0xf);
	XGpio_DiscreteSet(&Gpio2, 2, 0xf);

	/*
	 * Initialize the IIC driver so that it's ready to use
	 * Look up the configuration in the config table,
	 * then initialize it.
	 */

	Config = XIicPs_LookupConfig(XPAR_XIICPS_0_DEVICE_ID);
	if (NULL == Config) {
		return XST_FAILURE;
	}

	Status = XIicPs_CfgInitialize(&Iic, Config, Config->BaseAddress);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Perform a self-test to ensure that the hardware was built correctly.
	Status = XIicPs_SelfTest(&Iic);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	//Set the IIC serial clock rate.
	XIicPs_SetSClk(&Iic, 100000);

	printf("PS I2C Initialized\n\r");

	int status = I2C_read(0x1c, &LuxHighByte);
	if (status == XST_SUCCESS) {
		printf("succ ");
		printf("%x\n", LuxHighByte);
	} else
		printf("fail\n\r");

	usleep(100000);
	status = I2C_read(0x1d, &LuxHighByte);
	if (status == XST_SUCCESS) {
		printf("succ ");
		printf("%x\n", LuxHighByte);
	} else
		printf("fail\n\r");

	status = I2C_write( 0x12, 0x80);
	if (status == XST_SUCCESS)
		printf("succ\n\r");
	else
		printf("fail\n\r");

	usleep(100000);
	status = I2C_write( 0x70, 0x4a);
	if (status == XST_SUCCESS)
		printf("succ\n\r");
	else
		printf("fail\n\r");

	usleep(100000);
	status = I2C_write( 0x71, 0xb5);
	if (status == XST_SUCCESS)
		printf("succ\n\r");
	else
		printf("fail\n\r");

	status = I2C_write( 0xff, 0xff);
		if (status == XST_SUCCESS)
			printf("succ\n\r");
		else
			printf("fail\n\r");

	status = I2C_read( 0x70, &LuxHighByte);
	if (status == XST_SUCCESS) {
		printf("succ ");
		printf("%x\n", LuxHighByte);
	} else
		printf("fail\n\r");

	usleep(100000);

	status = I2C_read( 0x71, &LuxHighByte);
	if (status == XST_SUCCESS) {
		printf("succ ");
		printf("%x\n", LuxHighByte);
	} else
		printf("fail\n\r");

	usleep(100000);
	u8 data;
	u8 clk;
	u32 ar[1000];
	/*for(int i=0;i<1000;i++){
		ar[i]=XGpio_DiscreteRead(&Gpio,1);
	}*/
    while(1){
    	InputData=XGpio_DiscreteRead(&Gpio,1);
    	data=InputData&0xff;
    	clk= (InputData>>8)&0x7;
    	if((InputData & 0x300) == 0x300)
    		printf("%x %d %ld\n",clk,data,InputData);
    	//usleep(1000000);
    }


    printf("Testing Complete\n\r");


    //cleanup_platform();
    return 0;
}

int I2C_write(u8 register_offset, u8 write_value)
/*
* \brief       Use the Zynq IIC Controller to write a value to a
*              MAX44000 register at a given offset
*
* \param[in]   ZynqIicAddress    - address of the I2C Controller
* \param[in]   register_offset   - offset of register inside the MAX44000
* \param[in]   write_value       - value to be written to MAX44000 register
*
* \return      XST_SUCCESS if operation succeeded
*/
{
	int Status = XST_SUCCESS;
	u8 TxBuffer[128]; // Only need this to be size 2, but making larger for future use

	TxBuffer[0] = register_offset;  // Offset of register to write
	TxBuffer[1] = write_value;  // value to write there
	/* ADD HERE
	 *  Add code to send the 2 bytes contained in TxBuffer over I2C to
	 *  the device responding to I2C address MAX44000_IIC_ADDRESS.
	 *  The first byte of TxBuffer contains the offset to the register
	 *  inside the MAX44000. The second byte contains the data to be
	 *  written to that register. If the transfer fails, then
	 *  set Status to XST_FAILURE
	 */
	Status = XIicPs_MasterSendPolled(&Iic, TxBuffer, 2, IIC_ADDRESS);
	if (Status != XST_SUCCESS) return XST_FAILURE;
	//Wait until bus is idle to start another transfer.
	while (XIicPs_BusIsBusy(&Iic)) {/* NOP */}

	return(Status);
}

int I2C_read(u8 register_offset, u8 *read_value)
/*
* \brief       Use the Zynq IIC Controller to read a value from a
*              MAX44000 register at a given offset
*
* \param[in]   ZynqIicAddress    - address of the I2C Controller
* \param[in]   register_offset   - offset of register inside the MAX44000
* \param[in]   *read_value       - pointer to data read from MAX44000 register
*
* \return      XST_SUCCESS if operation succeeded
*/
{
	int Status = XST_SUCCESS;
	u8 TxBuffer[128]; // Only need this to be size 1, but making larger for future use
	u8 RxBuffer[128]; // Only need this to be size 1, but making larger for future use

	TxBuffer[0] = register_offset;
	/* ADD HERE
	 *  Add code to send 1 byte contained in TxBuffer over I2C to
	 *  the device responding to I2C address MAX44000_IIC_ADDRESS.
	 *  TxBuffer contains the offset to the register
	 *  inside the MAX44000. If the transfer fails, then
	 *  set Status to XST_FAILURE
	 */
	Status = XIicPs_MasterSendPolled(&Iic, TxBuffer, 1, IIC_ADDRESS);
	if (Status != XST_SUCCESS) return XST_FAILURE;
	//Wait until bus is idle to start another transfer.
	while (XIicPs_BusIsBusy(&Iic)) {/* NOP */}

	/* ADD HERE
	 *  Add code to receive 1 byte into RxBuffer over I2C from
	 *  the device responding to I2C address MAX44000_IIC_ADDRESS.
	 *  Since we previously sent the offset to the register
	 *  inside the MAX44000, the MAX44000 will now return the data
	 *  contained within that register. If the transfer fails, then
	 *  set Status to XST_FAILURE
	 */
	Status = XIicPs_MasterRecvPolled(&Iic, RxBuffer, 1, IIC_ADDRESS);
	if (Status != XST_SUCCESS)
		return XST_FAILURE;

	if(Status==XST_SUCCESS)
		*read_value = RxBuffer[0];

	usleep(100000); // Delay 100 ms, which is 100K us
	while (XIicPs_BusIsBusy(&Iic)) {/* NOP */}
	return(Status);
}
